<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初来乍到</title>
    <url>/2023/09/17/00-1/</url>
    <content><![CDATA[<p>写在开始…<br><br>初入职场，受组长凯哥影响，想要搭建自己的技术博客，于是有了这篇…<br><br>本人博客传送门：<a href="https://wzy012.github.io/">https://wzy012.github.io/</a> <br></p>
<p>2023.6.19 从SDU毕业<br><br>2023.8.3 入职byd<br><br>开始了自己的菜鸟<del>打工</del>（成长）生涯<br><br>从事智驾开发工作<br><br>作为一个7年的自动化<del>不</del>专业学生<br><br>进入了一个纯软的技术赛道<br><br>其实还是很有压力的<br><br>但同时感觉充满了兴奋与挑战<br><br>开个人博客的初衷是：<br></p>
<ul>
<li>记录自己学习各个技术的过程，形成文档以备查漏补缺；<br></li>
<li>如果有幸被需要的人看到，也是分享的意义</li>
</ul>
<p>希望自己坚持学习，一点一点进步，争取成为一名技术<del>大</del>小佬！</p>
<p>最后附：<br><br>    Hexo + Github + Git 的博客搭建方案链接：<a href="https://yushuaigee.gitee.io/archives/">https://yushuaigee.gitee.io/archives/</a><br><br>    vscode + PicGo + Markdown All in one 的配置链接：<a href="https://blog.csdn.net/qq_35621494/article/details/106432399">https://blog.csdn.net/qq_35621494/article/details/106432399</a><br></p>
<p>本人使用的是：vscode + Hexo + Github + Git + PicGO + Markdown All in one 的实现方案。</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>关于本人</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（统一建模语言）</title>
    <url>/2023/09/18/02-uml/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>通过使用UML使得在软件开发之前， 对整个软件设计有更好的可读性，可理解性，从而降低开发风险。同时，也能方便各个开发人员之间的交流。</p>
<h2 id="2-UML图分类"><a href="#2-UML图分类" class="headerlink" title="2 UML图分类"></a>2 UML图分类</h2><ul>
<li>UML图分为结构图和行为图；</li>
<li><strong>结构图</strong>分为: 类图、组件图、对象图、轮廓图、组合结构图、部署图、包图；</li>
<li><strong>行为图</strong>分为：活动图、用例图、状态机图、交互图。<br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918223614.png" alt="20230918223614"><br></li>
</ul>
<h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><h4 id="2-1-1-前言"><a href="#2-1-1-前言" class="headerlink" title="2.1.1 前言"></a>2.1.1 前言</h4><p><strong>概念</strong>：类图是一切面向对象方法的核心建模工具，类图描述了系统中对象的类型以及它们之间存在的各种静态关系；<br><br><strong>目的</strong>：表示类、接口以及它们之间的静态结构和关系。</p>
<h4 id="2-1-2-关系"><a href="#2-1-2-关系" class="headerlink" title="2.1.2 关系"></a>2.1.2 关系</h4><p>（1）泛化(Generalization)<br></p>
<ul>
<li>【泛化关系】是一种继承关系，表示子类继承父类的所有特征和行为。</li>
<li>【箭头指向】带三角箭头的实现，箭头指向父类。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225224.png" alt="20230918225224"><br><br>（2）实现(Realization)<br></li>
<li>【实现关系】是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li>
<li>【箭头指向】带三角箭头的虚线，箭头指向接口。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225239.png" alt="20230918225239"><br><br>（3）关联(Association)<br></li>
<li>【关联关系】是一种拥有关系，它使得一个类知道另一个的属性和方法。</li>
<li>【箭头指向】带普通箭头的实线，指向被拥有者。单向的关联只有一个箭头，双向的关联可以有两个箭头或者没有箭头。<br></li>
<li>【代码体现】成员变量。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225252.png" alt="20230918225252"><br><br>（4）聚合(Aggregation)<br></li>
<li>【聚合关系】是一种整体与部分的关系，且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li>
<li>【箭头指向】带空心菱形的实线，空心菱形指向整体。</li>
<li>【代码体现】成员变量。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225306.png" alt="20230918225306"><br><br>（5）组合(Composition)<br></li>
<li>【组合关系】是一种整体与部分的关系，但部分不能离开整体而单独存在。组合关系是关联关系的一种，是比聚合关系还要强的一种。</li>
<li>【箭头指向】带实心菱形和普通箭头的实现，实心菱形指向整体。</li>
<li>【代码体现】成员变量。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225319.png" alt="20230918225319"><br><br>（6）依赖(Dependency)<br></li>
<li>【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。</li>
<li>【箭头指向】带普通箭头的虚线，普通箭头指向被使用者。<br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918225336.png" alt="20230918225336"><br></li>
</ul>
<h4 id="2-2-组件图"><a href="#2-2-组件图" class="headerlink" title="2.2 组件图"></a>2.2 组件图</h4><ul>
<li>【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。</li>
<li>【目的】用来展示各个组件之间的依赖关系。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918230948.png" alt="20230918230948"><br><br>订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。</li>
</ul>
<h4 id="2-3-对象图"><a href="#2-3-对象图" class="headerlink" title="2.3 对象图"></a>2.3 对象图</h4><ul>
<li>【概念】对象图是类图的一个实例，是系统在某个时间点的详细状态的快照。</li>
<li>【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918230817.png" alt="20230918230817"><br><br>图中就是描述的，某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng。</li>
</ul>
<h4 id="2-4-轮廓图"><a href="#2-4-轮廓图" class="headerlink" title="2.4 轮廓图"></a>2.4 轮廓图</h4><h4 id="2-5-组合结构图"><a href="#2-5-组合结构图" class="headerlink" title="2.5 组合结构图"></a>2.5 组合结构图</h4><h4 id="2-6-部署图"><a href="#2-6-部署图" class="headerlink" title="2.6 部署图"></a>2.6 部署图</h4><h4 id="2-7-包图"><a href="#2-7-包图" class="headerlink" title="2.7 包图"></a>2.7 包图</h4><h4 id="2-8-活动图"><a href="#2-8-活动图" class="headerlink" title="2.8 活动图"></a>2.8 活动图</h4><ul>
<li>【概念】描述了具体业务用例的实现流程</li>
<li>【目的】用来表示用例实现的工作流程。</li>
</ul>
<h4 id="2-9-用例图"><a href="#2-9-用例图" class="headerlink" title="2.9 用例图"></a>2.9 用例图</h4><h4 id="2-10-状态机图"><a href="#2-10-状态机图" class="headerlink" title="2.10 状态机图"></a>2.10 状态机图</h4><h4 id="2-11-交互图"><a href="#2-11-交互图" class="headerlink" title="2.11 交互图"></a>2.11 交互图</h4><h4 id="2-12-序列图"><a href="#2-12-序列图" class="headerlink" title="2.12 序列图"></a>2.12 序列图</h4><h4 id="2-13-交互概览图"><a href="#2-13-交互概览图" class="headerlink" title="2.13 交互概览图"></a>2.13 交互概览图</h4><h4 id="2-14-通讯图"><a href="#2-14-通讯图" class="headerlink" title="2.14 通讯图"></a>2.14 通讯图</h4><h4 id="2-15-时序图"><a href="#2-15-时序图" class="headerlink" title="2.15 时序图"></a>2.15 时序图</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite数据库</title>
    <url>/2023/09/20/05-sqlitedb/</url>
    <content><![CDATA[<h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1 数据库"></a>1 数据库</h3><h4 id="1-1-数据库的基本概念"><a href="#1-1-数据库的基本概念" class="headerlink" title="1.1 数据库的基本概念"></a>1.1 数据库的基本概念<br></h4><p>数据库的核心概念包括数据、表格、字段、记录和主键等。<br></p>
<ul>
<li>数据<ul>
<li>数据是指可以被计算机处理和存储的信息。</li>
<li>数据可以是数字、字符、图像、音频等各种类型的信息。</li>
<li>数据库中的数据是有意义的信息，可以被组织、管理和检索。</li>
</ul>
</li>
<li>表格<ul>
<li>表格是数据库中存储数据的基本单元，也被称为数据表或数据集合。</li>
<li>表格由行和列组成，行表示记录，列表示字段。</li>
<li>表格中的每个单元格包含一个值，该值对应于表格中的一个字段和一条记录。</li>
</ul>
</li>
<li>字段<ul>
<li>字段是表格中的列，每个字段都包含相同类型的数据。</li>
<li>字段可以是数字、字符、日期、时间、布尔值等各种类型的数据。</li>
<li>每个字段都有一个名称，用于标识该字段在表格中的位置。</li>
</ul>
</li>
<li>记录<ul>
<li>记录是表格中的行，每个记录包含一组字段值。</li>
<li>记录的数量可以是零或多个，每个记录都有一个唯一标识符，称为主键。</li>
</ul>
</li>
<li>主键<ul>
<li>主键是一条记录的唯一标识符，用于区分表格中不同的记录。</li>
<li>主键可以是一个或多个字段的组合，主键的值不能重复。</li>
<li>主键可以是数据库中唯一的一个记录标识符。</li>
</ul>
</li>
</ul>
<h4 id="1-2-数据库的类型"><a href="#1-2-数据库的类型" class="headerlink" title="1.2 数据库的类型"></a>1.2 数据库的类型</h4><p>根据数据存储方式和结构的不同，数据库可以分为<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>：</p>
<ul>
<li>关系型数据库:<ul>
<li>采用关系模型来组织数据的数据库。关系模型是指将数据组织成一系列的表格，表格之间可以建立关系。</li>
<li>常见的关系型数据库有MySQL、Oracle、SQLServer、PostgreSQL等。</li>
<li>关系型数据库具有以下特点：<ul>
<li>表格之间可以建立关系，数据之间的关联性可以通过外键进行管理。</li>
<li>支持复杂的查询操作，可以通过SQL语句进行查询、更新、删除等操作。</li>
<li>支持事务处理，可以保证数据的完整性和一致性。通过索引来加快数据访问速度。</li>
</ul>
</li>
</ul>
</li>
<li>非关系型数据库（NoSQL）:<ul>
<li>非关系型数据库指不使用传统的关系型数据库模型的数据库，使用其他的数据模型来组织和管理数据。</li>
<li>非关系型数据库可以存储各种类型的数据，包括结构化、半结构化和非结构化的数据。</li>
<li>常见的非关系型数据库有MongoDB、Cassandra、Redis、Elasticsearch等。</li>
<li>非关系型数据库具有以下特点：<ul>
<li>不需要事先定义数据模型，数据可以动态添加和删除。</li>
<li>支持水平扩展，可以通过添加节点来扩展数据库的容量和性能。</li>
<li>支持高可用性和可伸缩性，可以通过复制和分片来实现数据的冗余和负载均衡。</li>
<li>支持键值对、文档、图形、列族等多种数据模型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-数据库的结构"><a href="#1-3-数据库的结构" class="headerlink" title="1.3 数据库的结构"></a>1.3 数据库的结构</h4><p>数据库的结构指的是数据在数据库中的组织形式和存储方式，根据数据库结构的不同，数据库可以分为层次型数据库、网状型数据库、关系型数据库和面向对象数据库等。</p>
<ul>
<li>层次型数据库层次型数据库（HierarchicalDatabase）：<ul>
<li>是最早的数据库类型之一，它的数据结构类似于一棵树形结构，数据之间存在一对多的层次关系。</li>
<li>每个节点可以包含多个子节点，但只能有一个父节点。</li>
<li>层次型数据库常用于管理复杂的工程和科学数据。</li>
</ul>
</li>
<li>网状型数据库网状型数据库（NetworkDatabase）<ul>
<li>是在层次型数据库的基础上发展起来的一种数据库类型。</li>
<li>网状型数据库的数据结构类似于一个网状结构，数据之间存在多对多的关系。</li>
<li>每个记录可以有多个父记录和多个子记录。</li>
<li>网状型数据库常用于处理复杂的关联数据。</li>
</ul>
</li>
<li>关系型数据库关系型数据库<ul>
<li>是目前应用最广泛的一种数据库类型，它的数据结构是由多个表格组成，表格之间可以建立关系。</li>
<li>关系型数据库可以使用SQL语句进行查询、更新、删除等操作，支持事务处理和索引等高级功能。</li>
</ul>
</li>
<li>面向对象数据库面向对象数据库（Object-orientedDatabase）<ul>
<li>是一种新型的数据库类型，它的数据结构类似于面向对象程序设计中的对象和类。</li>
<li>面向对象数据库将数据存储在对象中，对象之间可以建立关系和继承关系，支持多态和封装等面向对象的特性。</li>
<li>面向对象数据库常用于存储复杂的对象数据和多媒体数据</li>
</ul>
</li>
</ul>
<h3 id="2-SQLite-C-C-API"><a href="#2-SQLite-C-C-API" class="headerlink" title="2 SQLite-C&#x2F;C++API"></a>2 SQLite-C&#x2F;C++API</h3><ul>
<li>是一个嵌入式SQL数据库引擎</li>
<li>头文件：#include&lt;sqlite3.h&gt;</li>
<li>打开数据库。如果数据库不存在，则创建数据库；</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp">    <span class="token function">intsqlite3_open</span><span class="token punctuation">(</span>
        constchar<span class="token operator">*</span>filename<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/*Databasefilename(UTF-8)*/</span>
        sqlite3<span class="token operator">*</span><span class="token operator">*</span>ppDb           <span class="token comment" spellcheck="true">/*OUT:SQLitedbhandle*/</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">参数：
        `char*filename`：指定要打开的数据库的路径及文件名;
        `sqlite3**ppDb`：`sqlite3`句柄指针，存储打开的数据库的首地址;
返回值：
        成功，返回SQLITE_OK；其实就是0;
        失败，返回数据库中的error_code，其实就是大于0;
功能：
        1.打开一个指向SQLite数据库文件的连接，返回一个用于其他SQLite程序的数据库连接对象。
        2.如果filename参数是NULL或':memory:'，那么sqlite3_open()将会在RAM中创建一个内存数据库，这只会在session的有效时间内持续。
        3.如果文件名filename不为NULL，那么sqlite3_open()将使用这个参数值尝试打开数据库文件。如果该名称的文件不存在，sqlite3_open()将创建一个新的命名为该名称的数据库文件并打开。
</code></pre>
<ul>
<li>执行:</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp">    <span class="token function">SQLintsqlite3_exec</span><span class="token punctuation">(</span>
        sqlite3<span class="token operator">*</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true">/*sqlite3是打开的数据库对象*/</span>
        constchar<span class="token operator">*</span>sql<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">/*SQL命令，以\0结尾，可以由多个指令组成*/</span>
        sqlite_callback<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/*回调函数*/</span>
        <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">/*回调函数的第一个参数*/</span>
        <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span>errmsg        <span class="token comment" spellcheck="true">/*将被返回用来获取程序生成的任何错误*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">功能：
    1.提供了一个执行SQL命令的快捷方式
    2.`sqlite3_exec()`程序解析并执行由sql参数所给的每个命令，直到字符串结束或者遇到错误为止
    3.`sqlite3_callback`、`void*data`和`char**errmsg`都可以填NULL。
        填NULL表示你不需要回调。比如你做insert操作，做`delete`操作；
        而当做`select`时，就要使用回调，因为`sqlite3`把数据查出来，得通过回调告诉你查出了什么数据。
</code></pre>
<ul>
<li><p>非回调的select查询：<br><br><code>sqlite3_get_table()</code><br></p>
</li>
<li><p>函数关闭数据库<br><br><code>int sqlite3_close(sqlite3*)</code><br></p>
</li>
</ul>
<pre class=" language-text"><code class="language-text">功能：
    1.关闭之前调用sqlite3_open()打开的数据库连接
    2.如果还有查询没有完成，sqlite3_close()将返回SQLITE_BUSY禁止关闭的错误消息
</code></pre>
<ul>
<li>打印错误信息</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">   参数：
    sqlite3*db：数据库句柄指针;
  返回值：
    返回error_code对应的错误信息;
</code></pre>
<ul>
<li>打印<code>error_code</code></li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sqlite3_errcode</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">  参数：
    sqlite3*db：数据库句柄指针;
  返回值：对应的error_code;
</code></pre>
<ul>
<li>查询数据库:</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token function">intsqlite3_get_table</span><span class="token punctuation">(</span>
    sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span>
    constchar<span class="token operator">*</span>zSql<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/*sql语句，注意只能填查询相关的sql语句*/</span>
    <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> pazResult<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/*指向查询的结果 */</span>
    <span class="token keyword">int</span><span class="token operator">*</span> pnRow<span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">/*存储查询到的记录数，行数; */</span>
    <span class="token keyword">int</span><span class="token operator">*</span> pnColumn<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">/* 存储查询到的字段数，列数;*/</span>
    <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> pzErrmsg     <span class="token comment" spellcheck="true">/*存储错误信息; */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">  返回值：
    成功，返回SQLITE_OK；其实就是0;<br>
    失败，返回数据库中的error_code，其实就是大于0;<br>
</code></pre>
<ul>
<li>释放查询到的结果:</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sqlite3_free_table</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>执行准备操作:</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sqlite3_prepare_v2</span>
<span class="token punctuation">(</span>
    sqlite3<span class="token operator">*</span>db<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">//数据库连接对象</span>
    constchar<span class="token operator">*</span>zSql<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//要编译的SQL语句</span>
    intnByte<span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">//要编译的SQL语句的长度，如果是-1，则自动计算其长度</span>
    sqlite3_stmt<span class="token operator">*</span><span class="token operator">*</span>ppStmt<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//编译后的SQLite3语句对象</span>
    constchar<span class="token operator">*</span><span class="token operator">*</span>pzTail   <span class="token comment" spellcheck="true">//未编译部分的指针</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-text"><code class="language-text">  功能：
    该函数将SQL语句编译成SQLite虚拟机指令，并将编译后的SQLite3语句对象存储在ppStmt指向的指针中，以备执行。如果pzTail不是NULL，则该指针将指向SQL语句中未编译部分的起始位置。
  函数返回值：
    如果编译成功，则返回SQLITE_OK。
    如果编译失败，则返回一个错误代码sqlite3_step()
    返回值有三种结果:
        sqlite_done表示执行完毕;
        sqlite_busy,表示无法执行操作;
        sqlite_row表示执行完毕，并且有返回。
</code></pre>
<h3 id="1-3-Linux终端操作sqlite数据库"><a href="#1-3-Linux终端操作sqlite数据库" class="headerlink" title="1.3 Linux终端操作sqlite数据库"></a>1.3 Linux终端操作sqlite数据库</h3><pre class=" language-linux"><code class="language-linux">$ sqlite3<database_name>.db //打开/连接数据库
$ sqlite><SQL_statement>;//执行SQL语句
    $ sqlite>.tables//显示所有表格
    $ sqlite>.schema<table_name>//查看表的结构
    $ sqlite>SELECT*FROM<table_name>;//查询表中的所有结构$sqlite>INSERTINTO<table_name>(column1,column2,...)VALUES(value1,value2,...);
    $ sqlite>UPDATE<table_name>SETcolumn1=value1WHEREcondition;$sqlite>DELETEFROM<table_name>WHEREcondition;
$ .exit//退出sqlite3数据库
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite性能测试</title>
    <url>/2023/09/20/03-sqlite-performancetest/</url>
    <content><![CDATA[<p><strong>SQLite执行SQL语句有两种方式</strong>：<br><br>(1) 开启事务：使用函数<code>sqlite3_exec()</code>，该函数直接调用包含SQL语句的字符串，对循环中每一句SQL语句进行“词法分析”和“语法分析”；<br></p>
<ul>
<li>事务“就是指一组<code>SQL</code>命令，这些命令要么一起执行，要么都不被执行。<br></li>
<li>隐式开启事务：每调用一次<code>sqlite3_exec()</code>函数，就会隐式地开启了一个事务，如果插入一条数据，就调用该函数一次，事务就会被反复地开启、关闭，会增大IO量。<br></li>
<li>显式开启事务：如果在插入数据前显式开启事务，插入后再一起提交，则会大大提高<code>IO</code>效率，进而加数据快插入速度。<br><br>  【显示开始事务效率高】<br></li>
</ul>
<p>(2) 执行准备操作：使用函数<code>sqlite3_prepare_v2()</code>，有三个步骤：<br></p>
<ul>
<li>声明一个指向<code>sqlite3_stmt</code>对象的指针，该函数对参数化的SQL语句进行编译，将编译后的状态存入<code>stmt</code>中。<br></li>
<li>调用函数 <code>sqlite3_step()</code>，这个函数就是执行一步（本例中就是插入一行），如果函数返回的是<code>SQLite_ROW</code>则说明仍在继续执行，否则则说明已经执行完所有操作。<br></li>
<li>调用函数 <code>sqlite3_finalize()</code>，关闭语句。<br><br>   【执行准备操作效率高】</li>
</ul>
<p><strong>关闭写同步</strong>：<code>sqlite3_exec(db,&quot;PRAGMA synchronous = OFF; &quot;,0,0,0);</code>  <br></p>
<p>(1) 在<code>SQLite</code>中，数据库配置的参数都由编译指示<code>（pragma）</code>来实现的。<br></p>
<p>(2) <code>synchronous</code>选项有三种可选状态，分别是<code>full、normal、off</code>。<br></p>
<ul>
<li>当<code>synchronous</code>设置为<code>FULL,SQLite</code>数据库引擎在紧急时刻会暂停以确定数据已经写入磁盘。这使系统崩溃或电源出问题时能确保数据库在重起后不会损坏。<code>FULL synchronous</code>很安全但很慢。<br></li>
<li>当<code>synchronous</code>设置为<code>NORMAL, SQLite</code>数据库引擎在大部分紧急时刻会暂停，但不像<code>FULL</code>模式下那么频繁。<code> NORMAL</code>模式下有很小的几率(但不是不存在)发生电源故障导致数据库损坏的情况。<br></li>
<li>当<code>synchronous</code>设置<code>OFF</code>时，<code>SQLite</code>在传递数据给系统以后直接继续而不暂停。<code>off</code>可以加速数据库的一些操作，但如果系统崩溃或断电，则数据库可能会损毁。<br></li>
</ul>
<p>(3) <code>SQLite3</code>中，该选项的默认值就是<code>full</code>，如果我们再插入数据前将其改为off，则会提高效率。如果仅仅将<code>SQLite</code>当做一种临时数据库的话，完全没必要设置为<code>full</code>。<br></p>
<p><strong>总结</strong>:<br><br>1.显示开启事务效率更高；<br><br>2.如果使用<strong>执行准备操作</strong>,配合<strong>关闭写同步</strong>效率更高。<br></p>
<p>以以下为测试代码：<br></p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sqlite3.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">testInsertPerformance_prepare</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//执行准备操作</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>string query <span class="token operator">=</span> <span class="token string">"INSERT INTO your_table_name (column1, column2) VALUES (?, ?)"</span><span class="token punctuation">;</span>
    sqlite3_stmt<span class="token operator">*</span> stmt<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> value1 <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">int</span> value2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_prepare_v2</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> query<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stmt<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_step</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_finalize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"prepare: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testInsertPerformance_exec_a</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//隐式事务</span>
<span class="token punctuation">{</span>

    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"CREATE TABLE Test(ID INTEGER,var INTEGER);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"INSERT INTO Test (ID, var) VALUES (0, 1);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exec_a: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testInsertPerformance_exec_b</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//开启显式事务</span>
<span class="token punctuation">{</span>

    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"BEGIN"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"CREATE TABLE Test(ID INTEGER,var INTEGER);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"INSERT INTO Test (ID, var) VALUES (0, 1);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"COMMIT"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exec_b: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testInsertPerformance_exec_b_off</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//是否关闭写同步 + 执行显式事务</span>
<span class="token punctuation">{</span>
    
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token string">"PRAGMA synchronous = OFF; "</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"BEGIN"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"CREATE TABLE Test(ID INTEGER,var INTEGER);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"INSERT INTO Test (ID, var) VALUES (0, 1);"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"COMMIT"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exec_b_off: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testInsertPerformance_al</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//关闭写同步 + 开始显式事务 + 执行准备操作</span>
<span class="token punctuation">{</span>
    

    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token string">"PRAGMA synchronous = OFF; "</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">//sqlite3_exec(db, "BEGIN", 0, 0, 0);</span>
    std<span class="token operator">::</span>string query <span class="token operator">=</span> <span class="token string">"INSERT INTO your_table_name (column1, column2) VALUES (?, ?)"</span><span class="token punctuation">;</span>
    sqlite3_stmt<span class="token operator">*</span> stmt<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> value1 <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">int</span> value2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_prepare_v2</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> query<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stmt<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_step</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_finalize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//sqlite3_exec(db, "COMMIT", 0, 0, 0);</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exec_b_off: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">testInsertPerformance_all</span><span class="token punctuation">(</span>sqlite3<span class="token operator">*</span> db<span class="token punctuation">,</span> <span class="token keyword">int</span> numRecords<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//关闭写同步 + 开始显式事务 + 执行准备操作</span>
<span class="token punctuation">{</span>
    

    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span><span class="token string">"PRAGMA synchronous = OFF; "</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"BEGIN"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string query <span class="token operator">=</span> <span class="token string">"INSERT INTO your_table_name (column1, column2) VALUES (?, ?)"</span><span class="token punctuation">;</span>
    sqlite3_stmt<span class="token operator">*</span> stmt<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRecords<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> value1 <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">int</span> value2 <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_prepare_v2</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> query<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stmt<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_bind_int</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">sqlite3_step</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sqlite3_finalize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token string">"COMMIT"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token operator">::</span>chrono<span class="token operator">::</span>high_resolution_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> duration <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"exec_b_off: Time taken for "</span> <span class="token operator">&lt;&lt;</span> numRecords <span class="token operator">&lt;&lt;</span> <span class="token string">" inserts: "</span> <span class="token operator">&lt;&lt;</span> duration<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    sqlite3<span class="token operator">*</span> db<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//内存模式</span>
    <span class="token comment" spellcheck="true">//int rc = sqlite3_open(":memory:", &amp;db);</span>
    <span class="token comment" spellcheck="true">//磁盘模式</span>
    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">"/home/idc/TCP/db/mydatabase.db"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">!=</span> SQLITE_OK<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Cannot open database: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// Perform performance tests</span>
    <span class="token keyword">int</span> numRecords <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Adjust the number of records as needed</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"准备执行运行时间： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_prepare</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"显式开启事务运行时间： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_exec_b</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"隐式开启事务运行时间： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_exec_a</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"显式开启事务 + 关闭写同步 运行时间： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_exec_b_off</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"准备执行 + 关闭写同步： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_al</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"显式开启事务 + 关闭写同步 + 准备执行 运行时间： "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">testInsertPerformance_all</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> numRecords<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
    <span class="token function">sqlite3_close</span><span class="token punctuation">(</span>db<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>someip</title>
    <url>/2023/09/21/06-someip/</url>
    <content><![CDATA[<h3 id="1-SOA（Service-Oriented-Architecture）"><a href="#1-SOA（Service-Oriented-Architecture）" class="headerlink" title="1 SOA（Service Oriented Architecture）"></a>1 SOA（Service Oriented Architecture）</h3><h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><ul>
<li><strong>单体式应用程序</strong><br>所有功能模块包含在一个进程内功能模块之间通过直接调用API进行通信<br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232656.png" alt="20230921232656"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232719.png" alt="20230921232719"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232735.png" alt="20230921232735"><br></li>
<li><strong>SOA应用程序</strong><br>各个功能模块以独立进程（服务）运行功能模块之间通过服务接口进行通信<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232817.png" alt="20230921232817"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232847.png" alt="20230921232847"><br><br>图中：Process_C进程中divide服务接口想使用minus服务接口也必须需要使用IPC、网络，是因为minus以服务接口对外提供功能，没有提供API。<br></li>
</ul>
<p>服务等价于函数体；<br><br>服务是独立运行的进程，可以通过IPC、网络远程访问；<br><br>一个进程可以提供多个服务。<br></p>
<ul>
<li>服务接口<br><br>服务接口等价于函数接口；<br><br>服务接口是使用服务的唯一途径<br></li>
</ul>
<h4 id="1-2-SOA（面向服务的架构）："><a href="#1-2-SOA（面向服务的架构）：" class="headerlink" title="1.2 SOA（面向服务的架构）："></a>1.2 SOA（面向服务的架构）：</h4><h5 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h5><p>SOA是一个组件模型，将应用程序的不同功能单元（称为服务）进行拆分，并通过定义良好的通信机制【接口和协议】将这些服务联系起来。<br><br>接口是采用<strong>中立的方式</strong>【互联网、通信协议】进行定义的，它独立于实现服务的硬件平台、操作系统和编程语言，这使得在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921233039.png" alt="20230921233039"><br></p>
<h5 id="1-2-2-SOA中的-3-种角色："><a href="#1-2-2-SOA中的-3-种角色：" class="headerlink" title="1.2.2 SOA中的 3 种角色："></a>1.2.2 <strong>SOA中的 3 种角色</strong>：</h5><ul>
<li>服务提供者（server）：利用服务中心对外提供服务；响应客户端的请求</li>
<li>服务使用者（client）：利用服务中心查找所需的服务；使用服务</li>
<li>服务中心（位于server）：注册、保存服务提供者提供的服务，广播服务</li>
<li>服务中心（位于client）：查找网络中的有效服务，并通知client服务是否可用<br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921233313.png" alt="20230921233313"><br><br>一台设备有且只能有一个服务中心一台设备可有0个或多个服务提供者一台设备可有0个或多个服务使用者<br></li>
</ul>
<h5 id="1-2-3-SOA中的-4-种操作："><a href="#1-2-3-SOA中的-4-种操作：" class="headerlink" title="1.2.3 SOA中的 4 种操作："></a>1.2.3 <strong>SOA中的 4 种操作</strong>：</h5><ul>
<li>发布服务（server）：发布服务的具体信息到网络</li>
<li>查找服务（client）：查看目标服务在当前网络中是否可用</li>
<li>使用服务（client）：根据查找到的服务具体信息（ip\port\tcp&#x2F;udp）与服务提供者建立联系，使用服务<br></li>
<li>提供服务（server）：响应服务消费者的请求<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921233340.png" alt="20230921233340"><br></li>
</ul>
<h5 id="1-2-4-SOA的工作流程："><a href="#1-2-4-SOA的工作流程：" class="headerlink" title="1.2.4 SOA的工作流程："></a>1.2.4 <strong>SOA的工作流程</strong>：</h5><p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921233439.png" alt="20230921233439"><br></p>
<h5 id="1-2-5-SOA优势："><a href="#1-2-5-SOA优势：" class="headerlink" title="1.2.5 SOA优势："></a>1.2.5 SOA优势：</h5><p>优势：灵活适应业务变化、降低网络负担、通信机制标准化-跨平台、松耦合、隔离性、后期维护成本低<br><br>劣势：性能成本（IPC、网络通信）、维护开发成本<br></p>
<h3 id="2-someip"><a href="#2-someip" class="headerlink" title="2 someip"></a>2 <strong>someip</strong></h3><h4 id="2-1-someip与SOA的关系："><a href="#2-1-someip与SOA的关系：" class="headerlink" title="2.1 someip与SOA的关系："></a>2.1 someip与SOA的关系：</h4><p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231543.png" alt="20230921231543"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231616.png" alt="20230921231616"><br></p>
<p>SOME&#x2F;IP定义了服务提供者、服务使用者之间的通信接口<br><br>SD：service discovery<br><br>someip-sd协议是someip协议的特殊实现<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231711.png" alt="20230921231711"><br><br>some&#x2F;ip-sd是服务中心，只负责服务发现功能；<br></p>
<p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231730.png" alt="20230921231730"><br></p>
<p>some&#x2F;IP&amp;SD：服务中心不仅仅是服务中心，也可以是服务提供者、服务使用者。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231812.png" alt="20230921231812"><br></p>
<p>一台设备只能有一个sd<br></p>
<h4 id="2-2-someip工作原理："><a href="#2-2-someip工作原理：" class="headerlink" title="2.2 someip工作原理："></a>2.2 <strong>someip工作原理</strong>：</h4><p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231856.png" alt="20230921231856"><br></p>
<p>SOME&#x2F;IP协议位于TCP&#x2F;IP 5层模型中的第5层-应用层<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921231909.png" alt="20230921231909"><br></p>
<p>SOME&#x2F;IP中间件成功解耦了具体的应用与通信机制<br></p>
<h5 id="2-2-1-接口类型"><a href="#2-2-1-接口类型" class="headerlink" title="2.2.1 接口类型"></a>2.2.1 <strong>接口类型</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232007.png" alt="20230921232007"><br><br>(1) <strong>method方法</strong>：由client向server发送请求消息<br><br>RR：server需要回复的请求&#x2F;RR&#x3D;&#x3D;int func();<br><br>FF：server不需要回复的请求&#x2F;FF&#x3D;&#x3D; void func();<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232040.png" alt="20230921232040"><br><br>（2）<strong>event事件</strong>：由server向client发送事件消息<br><br>server会在合适的时候发送event消息给客户端<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232121.png" alt="20230921232121"><br></p>
<p>ps:subscribe eventgroup\ACK\stop subscribe是SD协议<br><br>事件组、强相关：将强相关的事件放到一个事件组中<br><br>客户端可以通过订阅事件组订阅感兴趣的事件<br><br>一个event（事件）必须加入事件组<br><br>一个event可以加入多个事件组<br><br>一个事件组中可以包含多个event<br><br>必须订阅event的所在事件组，不能订阅某个具体的event<br><br>(3) <strong>filed字段&#x2F;属性</strong>：一段内存空间的值，保存在server端<br><br>getter(method):获取，client可通过该方法主动从server获取field值<br><br>setter(method):设置，client可通过该方法设置field值<br><br>notifier(event):通知，当filed值发生改变，server就将最新值发送给client<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232208.png" alt="20230921232208"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232234.png" alt="20230921232234"><br><br>一个field必须加入事件组<br><br>一个field可以加入多个事件组<br><br>一个事件组中可以包含多个field<br><br>必须订阅field所在事件组，不能订阅某个具体的field<br></p>
<h5 id="2-2-2-someip服务接口："><a href="#2-2-2-someip服务接口：" class="headerlink" title="2.2.2 someip服务接口："></a>2.2.2 someip服务接口：</h5><p>所有接口都有ID（除了Field）：<br><br>service ID：区分系统里不同的服务，<br><br>Method ID：区分一个服务里的不同method，<br><br>Event ID：区分一个服务里的不同事件，<br><br>Eventgroup ID：区分事件组<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232404.png" alt="20230921232404"><br><br>同一服务的同类型接口ID不能重复<br><br>使用哪个服务哪个功能发生了哪个事件<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230921232533.png" alt="20230921232533"><br><br>第一个字段表示type、第二个表示ID<br><br>服务接口其实就是通信双方之间的交互机制<br><br>event notifier单向传输：只能由server端发起，发送给client<br></p>
<h3 id="3-关于汽车软件通信"><a href="#3-关于汽车软件通信" class="headerlink" title="3.关于汽车软件通信"></a>3.关于汽车软件通信</h3><p>传统的车载软件通信采用的是经典的总线协议（比如CAN、LIN、FlexRay），这些总线采用的是面向信号的数据传输(Signal-based)，基于信号在双绞线中的传输来通信，但是这些协议的传输带宽和传输速率有限，且不容易实现基于无线网更新车载软件(OTA)的需求。因此，新一代的车载软件通信更多采用了SOA架构下的SOME&#x2F;IP协议，该协议采用的是面向服务的数据传输(Service-Oriented)，基于ECU的服务在车载以太网中被请求或订阅来通信。<br><br>有用链接：<br><br><a href="https://www.51fusa.com/client/information/informationdetail/id/1788.html">https://www.51fusa.com/client/information/informationdetail/id/1788.html</a><br><br><a href="https://blog.csdn.net/qq_42981705/article/details/130735667">https://blog.csdn.net/qq_42981705/article/details/130735667</a><br><br><a href="https://mp.weixin.qq.com/s/rCRuCbHb_SUyysA7lWUPGA">https://mp.weixin.qq.com/s/rCRuCbHb_SUyysA7lWUPGA</a><br></p>
]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>SOME/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/09/17/01-sorting-algorithm/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>排序算法分为 <strong>内部排序</strong> 和 <strong>外部排序</strong>，其中:<br><br><strong>内部排序</strong>：是数据记录在内存中进行排序；<br><br><strong>外部排序</strong>：因为要排序的数据很大，内存一次性不能容纳全部的排序记录，在排序中需要访问外存。<br><br>ps:简单排序：冒泡排序、选择排序、插入排序； 高级排序：希尔排序、归并排序、快速排序。</p>
<h2 id="2-常见（内部）排序算法"><a href="#2-常见（内部）排序算法" class="headerlink" title="2 常见（内部）排序算法"></a>2 常见（内部）排序算法</h2><p>常见的内部排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等。<br></p>
<h3 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h3><h4 id="2-1-1-算法步骤"><a href="#2-1-1-算法步骤" class="headerlink" title="2.1.1 算法步骤"></a>2.1.1 算法步骤</h4><p>（1）比较相邻的元素。如果第一个比第二个大，就交换他们两个；<br><br>（2）对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大的值；<br><br>（3）重复以上步骤，每次比较次数-1，直到不需要比较。<br></p>
<h4 id="2-1-2-代码实现"><a href="#2-1-2-代码实现" class="headerlink" title="2.1.2 代码实现"></a>2.1.2 代码实现</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 排序的总趟数=元素个数-1；</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 每趟对比次数=元素个数-当前排序趟数-1；</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 相邻元素比较</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printArr</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> arrf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">17.5</span><span class="token punctuation">,</span> <span class="token number">19.1</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token number">1.9</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">,</span> <span class="token number">12.4</span><span class="token punctuation">,</span> <span class="token number">3.8</span><span class="token punctuation">,</span> <span class="token number">19.7</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">25.4</span><span class="token punctuation">,</span> <span class="token number">28.6</span><span class="token punctuation">,</span> <span class="token number">4.4</span><span class="token punctuation">,</span> <span class="token number">23.8</span><span class="token punctuation">,</span> <span class="token number">5.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-1-3-性能分析"><a href="#2-1-3-性能分析" class="headerlink" title="2.1.3 性能分析"></a>2.1.3 性能分析</h4><p>时间复杂度：O(N^2) <br><br>空间复杂度：O(1)</p>
<h3 id="2-2-选择排序"><a href="#2-2-选择排序" class="headerlink" title="2.2 选择排序"></a>2.2 选择排序</h3><h4 id="2-2-1-算法步骤"><a href="#2-2-1-算法步骤" class="headerlink" title="2.2.1 算法步骤"></a>2.2.1 算法步骤</h4><p>（1）在每一次遍历的过程中，都假定第一个索引处的元素是最小值，并和其他索引处的值进行比较，如果当前索引处的值大于其他索引处的值，则假定其他索引处的值为最小值，最后可以找到最小值所在的索引；<br><br>（2）交换第一个索引处和最小值所在的索引处的值。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230917221302.png" alt="20230917221302"></p>
<h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 排序的总趟数=元素个数-1；</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置</span>
        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 比较 最小索引处minIndex处的值 与 j索引处的值 的大小</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//交换最小元素所在索引minIndex处的值和第一个位置处的值</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> intv<span class="token punctuation">;</span>
    intv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    intv<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">selection_sort</span><span class="token punctuation">(</span>intv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> intv<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-2-3-性能分析"><a href="#2-2-3-性能分析" class="headerlink" title="2.2.3 性能分析"></a>2.2.3 性能分析</h4><p>时间复杂度：O(N^2) <br><br>空间复杂度：O(1)</p>
<h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><h4 id="2-3-1-算法步骤-原理"><a href="#2-3-1-算法步骤-原理" class="headerlink" title="2.3.1 算法步骤&#x2F;原理"></a>2.3.1 算法步骤&#x2F;原理</h4><p>（1）把所有的元素分为两组，已经排序的和未排序的；<br><br>（2）找到未排序的组中的第一个元素，向已经排序的组中进行插入；<br><br>（3）倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918222309.png" alt="20230918222309"><br><br>ps:假设排序前的数组的第一个的元素为已排序，其余为未排序</p>
<h4 id="2-3-2-代码实现"><a href="#2-3-2-代码实现" class="headerlink" title="2.3.2 代码实现"></a>2.3.2 代码实现</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 索引0处为已排序，待排序的元素索引从1开始</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 比较索引j处的值和索引j-1处的值，</span>
            <span class="token comment" spellcheck="true">// 如果j-1处的值大于j处的值，则交换位置；</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 否则找到合适的位置退出循环</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printArr</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-3-3-性能分析"><a href="#2-3-3-性能分析" class="headerlink" title="2.3.3 性能分析"></a>2.3.3 性能分析</h4><p>时间复杂度：O(N^2)<br><br>空间复杂度：O(1)，稳定的排序算法<br><br>ps:元素集合越接近有序，插入排序算法的时间效率越高</p>
<h3 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h3><p>希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版。</p>
<h4 id="2-4-1-算法步骤-原理"><a href="#2-4-1-算法步骤-原理" class="headerlink" title="2.4.1 算法步骤&#x2F;原理"></a>2.4.1 算法步骤&#x2F;原理</h4><p>（1）选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；<br><br>（2）对分好组的每一组数据完成插入排序；<br><br>（3）减小增长量，最小减为1，重复第二步操作。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230918222218.png" alt="20230918222218"><br><br><strong>增量h的确定规则：</strong></p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// h初始化</span>
<span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>h <span class="token operator">&lt;</span> 数组的长度<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    h <span class="token operator">=</span> 2h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 减小规则</span>
h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="2-4-2-代码实现-核心代码"><a href="#2-4-2-代码实现-核心代码" class="headerlink" title="2.4.2 代码实现&#x2F;核心代码"></a>2.4.2 代码实现&#x2F;核心代码</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.根据数组长度确定增长量h的初始值</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>h <span class="token operator">&lt;</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        h <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 2.希尔排序</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 排序</span>
        <span class="token comment" spellcheck="true">// 2.1 找到待插入的元素</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 2.2 将待插入的元素插入到有序数列中</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">>=</span> h<span class="token punctuation">;</span> j<span class="token operator">-</span><span class="token operator">=</span>h<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 待插入的元素是a[j],比较a[j]和a[j-h]</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token operator">-</span>h<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token operator">-</span>h<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment" spellcheck="true">// 减小h的值</span>
        h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-4-3-性能分析"><a href="#2-4-3-性能分析" class="headerlink" title="2.4.3 性能分析"></a>2.4.3 性能分析</h4><p>时间复杂度O(N^1.5) [不好计算]<br><br>空间复杂度O(1)<br><br>ps: 非稳定排序算法,当h&gt;1时都是预排序，目的是让数组更接近于有序。当h&#x3D;&#x3D;1时，数组接近有序的，排序就会更快。<br></p>
<h3 id="2-5-归并排序"><a href="#2-5-归并排序" class="headerlink" title="2.5 归并排序"></a>2.5 归并排序</h3><h4 id="2-5-0-递归"><a href="#2-5-0-递归" class="headerlink" title="2.5.0 递归"></a>2.5.0 递归</h4><ul>
<li>定义：在方法内部调用方法本身；<br></li>
<li>作用：可以把一个大型复杂问题层层转换为一个与原问题相似的、规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大减少程序的代码量。<br></li>
<li>注意事项：递归必须要有边界条件能够让递归结束，因为每一次调用都会在<strong>栈内存</strong>开辟新的空间，重复执行方法，如果递归的层级太深，很容易造成栈内存溢出。<br></li>
<li>代码示例(n的阶乘)：</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-5-1-算法步骤-原理"><a href="#2-5-1-算法步骤-原理" class="headerlink" title="2.5.1 算法步骤&#x2F;原理"></a>2.5.1 算法步骤&#x2F;原理</h4><p>(1) 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止；<br><br>(2) 将相邻的两个子组进行合并成一个有序的大组；<br><br>(3) 不断地重复步骤2，直到最终只有一个组为止。<br><br>ps:该算法采用分治法<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920215644.png" alt="20230920215644"><br><br>合并的具体过程：<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920223650.png" alt="20230920223650"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920223732.png" alt="20230920223732"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920223619.png" alt="20230920223619"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920224044.png" alt="20230920224044"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920224130.png" alt="20230920224130"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920224231.png" alt="20230920224231"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920224343.png" alt="20230920224343"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230920224419.png" alt="20230920224419"><br></p>
<h4 id="2-5-2-代码实现"><a href="#2-5-2-代码实现" class="headerlink" title="2.5.2 代码实现"></a>2.5.2 代码实现</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 递归实现</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 做安全性校验</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>begin <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 对begin到end之间的数据进行分组</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 分别对每一组数据进行排序</span>
    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 再把两个组中的数据进行归并</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义三个指针</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> p1 <span class="token operator">=</span> begin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment" spellcheck="true">// 初始化一个辅助数组</span>
    T assist<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 遍历，移动p1指针和p2指针，比较对应索引处的值，找出最小的值，放到辅助数组的对应索引处</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 遍历，如果p1的指针没有走完， 那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 遍历，如果p2的指针没有走完， 那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 把辅助数组中的元素拷贝到原数组中</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> assist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-5-3-性能分析"><a href="#2-5-3-性能分析" class="headerlink" title="2.5.3 性能分析"></a>2.5.3 性能分析</h4><p>时间复杂度：O(NlogN) <br><br>空间复杂度：O(N) <br><br>分析过程：<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922152626.png" alt="20230922152626"><br><br>用树状图描述归并排序，如图所示，一个数组有8个元素，每次除以2找最小的子数组，共拆分log2^8次即3次，所以树共有3层。<br><br>那么，自顶向下第k层共有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较；<br><br>因此，每层的比较次数为2^k*2^(3-k)&#x3D;2^3,那么3层共有3*2^3。<br><br>|递推<br><br>假设元素的个数为n，那么使用归并排序拆分的次数为log2(n)，所以共log2(n)层，最终得出的归并排序的时间复杂度为：<br><br>log2(n)*2^(log2(n))&#x3D;log(n)*n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn);</p>
<h3 id="2-6-快速排序"><a href="#2-6-快速排序" class="headerlink" title="2.6 快速排序"></a>2.6 快速排序</h3><h4 id="2-6-1-算法步骤-原理"><a href="#2-6-1-算法步骤-原理" class="headerlink" title="2.6.1 算法步骤&#x2F;原理"></a>2.6.1 算法步骤&#x2F;原理</h4><p>快递排序是对冒泡排序的一种改进，基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有元素都比另外一部分的所有元素都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br><br>(1)首先设定一个分界值，通过该分界值将数组分成两部分；<br><br>(2)将大于或等于分界值的数据放到数组右边，小于分界值的数据放到数组左边。此时左边部分中各元素都小于等于分界值，而右边部分中各元素都大于等于分界值；<br><br>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。<br><br>(4)重复上述过程，可以看出这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922155945.png" alt="20230922155945"><br><br><strong>切分原理</strong>：<br>把一个数组切分成两个子数组的基本思想：<br><br>（1）找一个基准值，用两个指针分别指向数组的头部和尾部；<br><br>（2）先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；<br><br>（3）再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；<br><br>（4）交换当前左边指针位置和右边指针位置的元素；<br><br>（5）重复2，3，4步骤，直到左边指针的值大于右边指针的值停止。<br><br>具体的切分过程：<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922162752.png" alt="20230922162752"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922162954.png" alt="20230922162954"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922163111.png" alt="20230922163111"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230922163331.png" alt="20230922163331"><br></p>
<h4 id="2-6-2-代码实现"><a href="#2-6-2-代码实现" class="headerlink" title="2.6.2 代码实现"></a>2.6.2 代码实现</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//end = size()-1</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 安全性校验</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">&lt;=</span> begin<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//对数组[begin, end]的元素进行分组（左子组，右子组）</span>
    <span class="token keyword">int</span> partition <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//让左子组有序</span>
    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> partition<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//让右子组有序</span>
    <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partition<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 对数组arr，从索引begin到end之间的元素进行分组，并返回分组界限对应的索引</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 确定分界值</span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> begin<span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 写法：</span>
    <span class="token comment" spellcheck="true">// int right = end;</span>
    <span class="token comment" spellcheck="true">//切分</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 先从右向左扫描，移动right指针，找到一个比分界值小的元素，停止</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span><span class="token operator">--</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> begin<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 再先从左向右扫描，移动left指针，找到一个比分界值大的元素，停止</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">++</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> end<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// Line 411 ~ 425 另外一种写法</span>
        <span class="token comment" spellcheck="true">// while(left &lt; right &amp;&amp; arr[right] > key)</span>
        <span class="token comment" spellcheck="true">//     --right;</span>
        <span class="token comment" spellcheck="true">// while(left &lt; right &amp;&amp; arr[left] &lt; key)</span>
        <span class="token comment" spellcheck="true">//     ++left;</span>

        <span class="token comment" spellcheck="true">// 判断 left>=right，如果是则证明元素扫描完毕，结束循环；否则交换元素即可</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="2-6-3-性能分析"><a href="#2-6-3-性能分析" class="headerlink" title="2.6.3 性能分析"></a>2.6.3 性能分析</h4><p>（1）快速排序和归并排序的区别<br><br>快速排序也是一种分治的排序算法；<br><br>快递排序和归并排序是互补的，归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式是则当两个子数组有序时整个数组自然就有序了。<br><br>在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。<br><br>（2）复杂度分析<br><br>时间复杂度：<br><br>最好情况：每一次切分选择的基准数字刚好将当前序列等分，O(nlogn)；<br><br>最坏情况：每次切分选择的基准数字是最大值最小值；O(n^2);<br><br>平均情况：每次切分选择的基准数字不是最大值最小值，也不是中值，可用数学归纳法证明，快速排序的时间复杂度为O(nlogn)<br><br>空间复杂度：O(n)</p>
<h4 id="2-6-4-算法优化"><a href="#2-6-4-算法优化" class="headerlink" title="2.6.4 算法优化"></a>2.6.4 算法优化</h4><p><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/p57uhr/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/p57uhr/</a></p>
<h2 id="3-排序的稳定性"><a href="#3-排序的稳定性" class="headerlink" title="3. 排序的稳定性"></a>3. 排序的稳定性</h2><p><strong>稳定性概述</strong>：</p>
<ul>
<li>稳定性的定义：数组中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，则说这个算法是稳定。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230923121043.png" alt="20230923121043"><br></li>
<li>稳定性的意义：<br><br>一组数据只需要一次排序，则稳定性一般是没有意义的；如果一组数据需要多次排序，稳定性是有意义的。<br><br><strong>常见排序算法的稳定性</strong>：<br></li>
<li>冒泡排序：元素相等的时候不交换位置，所以冒泡排序是一种稳定排序算法；</li>
<li>选择排序：假设第一个元素是最小的元素（已排序），与待排序数组的元素进行比较，找最小的元素；如数组{5(1), 8, 5(2), 2, 9},当遍历到2时，5（1）和2会交换位置，此时5(1)会交换到5(2)后面，破坏了稳定性；<br></li>
<li>插入排序：不交换相等元素的位置，所以稳定；<br></li>
<li>希尔排序：是按照不同步长对元素进行插入排序，虽然一次插入排序稳定，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，稳定性可能会打乱，所以不稳定；<br></li>
<li>归并排序：稳定<br></li>
<li>快速排序：需要一个基准值，在基准值右侧找比基准值大的元素，在基准值的左侧找比基准值小的元素，然后交换元素，会破坏稳定性，所以不稳定<br></li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>（1）简单排序算法的时间复杂度都为O(N^2)，随着输入规模的增大，时间成本急剧上升，因此简单排序算法不能处理大规模问题；<br><br>（2）排序的稳定性：<br><br>稳定的排序算法：冒泡排序、插入排序、归并排序；<br><br>不稳定的排序算法：选择排序、希尔排序、快速排序。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础知识</title>
    <url>/2023/09/20/04-datastructure/</url>
    <content><![CDATA[<h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h3><h4 id="3-1-前言"><a href="#3-1-前言" class="headerlink" title="3.1 前言"></a>3.1 前言</h4><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。</p>
<h4 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h4><p>固定数组和可变数组</p>
<h4 id="3-3-链表"><a href="#3-3-链表" class="headerlink" title="3.3 链表"></a>3.3 链表</h4><p>链表以节点为单位，每个元素都是一个独立对象，在内存中的存储空间是非连续的。链表的节点对象具有两个成员变量：「值 <code>val</code>」，「后继节点引用 <code>next</code>」 。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> ListNode<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="3-4-栈"><a href="#3-4-栈" class="headerlink" title="3.4 栈"></a>3.4 栈</h4><p>栈是一种具有 「先入后出」 特点的抽象数据结构，可使用<strong>数组</strong>或<strong>链表</strong>实现</p>
<pre class=" language-cpp"><code class="language-cpp">stack<span class="token operator">&lt;</span>T<span class="token operator">></span> stk<span class="token punctuation">;</span>
</code></pre>
<h4 id="3-5-队列"><a href="#3-5-队列" class="headerlink" title="3.5 队列"></a>3.5 队列</h4><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用<strong>链表</strong>实现。</p>
<pre class=" language-cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span>T<span class="token operator">></span> que<span class="token punctuation">;</span>
</code></pre>
<h4 id="3-6-树"><a href="#3-6-树" class="headerlink" title="3.6 树"></a>3.6 树</h4><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> TreeNode<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    TreeNode <span class="token operator">*</span>left<span class="token punctuation">;</span>
    TreeNode <span class="token operator">*</span>right<span class="token punctuation">;</span>
    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>构建二叉树示例：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//初始化节点</span>
TreeNode <span class="token operator">*</span>n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// root</span>
TreeNode <span class="token operator">*</span>n2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
TreeNode <span class="token operator">*</span>n3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
TreeNode <span class="token operator">*</span>n4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
TreeNode <span class="token operator">*</span>n5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//构建引用指向</span>
n1<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n2<span class="token punctuation">;</span>
n1<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n3<span class="token punctuation">;</span>
n2<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n4<span class="token punctuation">;</span>
n2<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n5<span class="token punctuation">;</span>
</code></pre>
<h4 id="3-7-图"><a href="#3-7-图" class="headerlink" title="3.7 图"></a>3.7 图</h4><p>图是一种非线性数据结构，由「节点（顶点）<code>vertex</code>」和「边 <code>edge</code>」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」，根据顶点之间是否有权重，分为[有权图]和[无权图]。</p>
<p><strong>以无向图为例</strong> 开展介绍，无向图的 <strong>顶点</strong> 和 <strong>边</strong> 集合分别为：</p>
<ul>
<li>顶点集合：<code>vertices = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li>边集合：<code>edges = &#123;(1, 2), (1, 3), (1, 4), (1, 5), (2,4), (3,5), (4,5)&#125;</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230923163558.png" alt="20230923163558"><br><strong>表示图</strong>的方法通常有两种：<br>1.<strong>邻接矩阵</strong>：使用数组vertices存储顶点，邻接矩阵edges存储边；<code>edges[i][j]</code>代表节点<code>i+1</code>和节点<code>j+1</code>之间是否有边。</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> vertices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> edges<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>2.<strong>邻接表</strong>：使用数组vertices存储顶点，邻接矩阵edges存储边。edges为一个二维容器，第一维<code>i</code>代表顶点索引，第二维edges[i]存储此顶点对应的边集合。<br>上图对应的邻接表为：</p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> vertices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> edges <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">4</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span> <span class="token punctuation">;</span>
</code></pre>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> vertices<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> edge_1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> edge_2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> edge_3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> edge_4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> edge_5 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>edge_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>edge_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>edge_3<span class="token punctuation">)</span><span class="token punctuation">;</span>
edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>edge_4<span class="token punctuation">)</span><span class="token punctuation">;</span>
edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>edge_5<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>邻接矩阵 VS 邻接表 ：<br><br>邻接矩阵的大小只与节点数量有关，即 N^2  ，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。<br><br>因此，邻接表 适合存储稀疏图（顶点较多、边较少）； 邻接矩阵 适合存储稠密图（顶点较少、边较多）。<br></p>
<h4 id="3-8-散列表"><a href="#3-8-散列表" class="headerlink" title="3.8 散列表"></a>3.8 散列表</h4><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。<br></p>
<pre class=" language-text"><code class="language-text">设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。
现需求从「姓名」查找「学号」。
</code></pre>
<pre class=" language-cpp"><code class="language-cpp">unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span>

dic<span class="token punctuation">[</span><span class="token string">"小力"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10001</span>；
dic<span class="token punctuation">[</span><span class="token string">"小特"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10002</span>；
dic<span class="token punctuation">[</span><span class="token string">"小扣"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10003</span>；

dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小力"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span>
dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小特"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span>
dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小扣"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span>
</code></pre>
<p><strong>Hash函数设计Demo</strong>：</p>
<pre class=" language-text"><code class="language-text">需求：从「学号」查找「姓名」
</code></pre>
<p>将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。<br></p>
<pre class=" language-cpp"><code class="language-cpp">string names<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"小力"</span><span class="token punctuation">,</span> <span class="token string">"小特"</span><span class="token punctuation">,</span> <span class="token string">"小扣"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>此时，我们构造一个简单的 Hash 函数（ % 为取余符号 ），公式和封装函数如下所示：</p>
<pre class=" language-text"><code class="language-text">hash(key) = (key -1)%10000;
</code></pre>
<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>id <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10000</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> index<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在O(1) 时间复杂度下通过学号查找到对应姓名，即：</p>
<pre class=" language-cpp"><code class="language-cpp">names<span class="token punctuation">[</span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
names<span class="token punctuation">[</span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token number">10002</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
names<span class="token punctuation">[</span><span class="token function">hash</span><span class="token punctuation">(</span><span class="token number">10003</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230923172308.png" alt="20230923172308"><br></p>
<h4 id="3-9-堆"><a href="#3-9-堆" class="headerlink" title="3.9 堆"></a>3.9 堆</h4><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。<br><br>以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。<br><br>堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值小于等于（大于等于）其父节点的值。<br></p>
<pre class=" language-text"><code class="language-text">完全二叉树定义： 设二叉树深度为 k ，若二叉树除第 k 层外的其它各层（第 1 至 k-1层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20230923172803.png" alt="20230923172803"><br><br>通过使用「优先队列」的「压入 push()」和「弹出 pop()」操作，即可完成堆排序，实现代码如下：<br></p>
<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化小顶堆</span>
priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> heap<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 元素入堆</span>
heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 元素出堆（从小到大）</span>
heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 1</span>
heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 2</span>
heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 4</span>
heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 6</span>
heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 8</span>
</code></pre>
<p>常用的线性结构有：线性表，栈，队列，双队列，数组，串。<br>常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图，堆。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2023/09/27/07-tree/</url>
    <content><![CDATA[<p><strong>线性序列</strong>：<br>查找：线性搜索（Liner search），时间复杂度为O(N)；<br><br>     【有序序列】二分查找（Binary search）: 时间复杂度为O(log2^N);<br><br>插入和删除操作：时间复杂度为O(N);<br></p>
<p><strong>二叉树（Binary search tree， BST）</strong>:<br>对于每一个节点，满足左子树的值小于该节点的值，右子树的值大于该节点的值。<br></p>
<ul>
<li>查找：从根节点走到叶子节点，时间复杂度ｏ(h);<br>如果构造为一个平衡的二叉树，高度为h，每层的节点个数为1, 2, 2^2, …, 2^(h-1),总节点数为2^h-1，则h&#x3D;log2^n+1，因此遍历的时间复杂度为<code>n = log2^h + 1</code>;<br></li>
<li>插入&#x2F;删除：</li>
</ul>
<p><strong>平衡二叉树</strong>：<br>满足二叉树的特性，同时对于任何一个节点：平衡因子为<code>|Height(RightTree) - Height(LeftTree)| &lt;= 1</code>或<code>|Height(LeftTree) - Height(RightTree) &lt;= 1</code>;<br><br>因此平衡二叉树的高度为：<code>h = log2^n + 1</code>; <br><br>查找的时间复杂度为：<code>O(log2^n)</code>;<br><br>插入：<br><br>插入有时会失去平衡：线型、∟型等<br><br><code>Four Cases:LL, RR, LR, RL</code><br></p>
<ul>
<li>LL:左节点的左子树：可右旋<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001210901.png" alt="20231001210901"><br></li>
<li>RR：右节点的右子树：可左旋<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001211036.png" alt="20231001211036"><br></li>
<li>LR：左节点的右子树：先左旋再右旋<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001212345.png" alt="20231001212345"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001212604.png" alt="20231001212604"><br><br></li>
<li>RL：右节点的左子树：先右旋再左旋<br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001212953.png" alt="20231001212953"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001213142.png" alt="20231001213142"><br></li>
</ul>
<p>插入删除需要不断调整结构，效率低；<br><br>**红黑树(Red-Black Tree)**：<br>红黑树是一个自平衡(self-balanced)的二叉搜索树;<br><br>如果搜索频繁插入删除不多可用平衡二叉树，插入删除多用红黑树；<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001214149.png" alt="20231001214149"><br><br><strong>特点</strong>：<br>（1）[root property]根节点是黑色的;<br><br>（2）[red property]红节点的子节点是黑色的；<br><br>（3）[black property]对于任何一个节点，从该节点到叶子节点包含的黑节点的个数相同；<br><br>（4）红黑树的高度最多为<code>2*log2^(n+1)</code><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001215037.png" alt="20231001215037"><br><br>Black Height(bh(x)):从任何一个节点x到叶子节点经过的黑色节点的数量;<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001215501.png" alt="20231001215501"><br><br>命题：<br><br>(1)任何一个节点x的子树至少有2^bh(x)-1个内部节点（internal node）<br><br>(2)任何一个节点的高度h(x)满足 bh(x)&gt;&#x3D;h(x)&#x2F;2;<br><br>对于一个根节点有：<br><br><code>n &gt;= 2^bh(root) - 1</code>;<br><br><code>bh(root)&gt;=h/2</code>;<br><br>可得：<code>h &lt;= 2log2^(n+1)</code><br><br>因此，RBT的时间复杂度为:O(h)&#x3D;O(log2^n)。<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001220041.png" alt="20231001220041"><br><br>RBT的插入:<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001221246.png" alt="20231001221246"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001221512.png" alt="20231001221512"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001221845.png" alt="20231001221845"><br><br><strong>总结</strong>：<br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001222017.png" alt="20231001222017"><br><br><img src="https://cdn.jsdelivr.net/gh/wzy012/myblogPicBed@master/image/20231001222046.png" alt="20231001222046"><br></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
